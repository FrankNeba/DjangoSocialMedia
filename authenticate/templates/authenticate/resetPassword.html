tId;
      parseCallExpressionArguments();
      _base.state.tokens[_base.state.tokens.length - 1].contextId = callContextId;

      if (shouldParseAsyncArrow()) {
        // We hit an arrow, so backtrack and start again parsing function parameters.
        _base.state.restoreFromSnapshot(snapshot);
        stopState.stop = true;
        _base.state.scopeDepth++;

        _statement.parseFunctionParams.call(void 0, );
        parseAsyncArrowFromCallExpression(asyncStartTokenIndex);
      }
    } else {
      _index3.next.call(void 0, );
      _base.state.tokens[_base.state.tokens.length - 1].subscriptStartIndex = startTokenIndex;
      const callContextId = _base.getNextContextId.call(void 0, );
      _base.state.tokens[_base.state.tokens.length - 1].contextId = callContextId;
      parseCallExpressionArguments();
      _base.state.tokens[_base.state.tokens.length - 1].contextId = callContextId;
    }
  } else if (_index3.match.call(void 0, _types3.TokenType.backQuote)) {
    // Tagged template expression.
    parseTemplate();
  } else {
    stopState.stop = true;
  }
} exports.baseParseSubscript = baseParseSubscript;

 function atPossibleAsync() {
  // This was made less strict than the original version to avoid passing around nodes, but it
  // should be safe to have rare false positives here.
  return (
    _base.state.tokens[_base.state.tokens.length - 1].contextualKeyword === _keywords.ContextualKeyword._async &&
    !_util.canInsertSemicolon.call(void 0, )
  );
} exports.atPossibleAsync = atPossibleAsync;

 function parseCallExpressionArguments() {
  let first = true;
  while (!_index3.eat.call(void 0, _types3.TokenType.parenR) && !_base.state.error) {
    if (first) {
      first = false;
    } else {
      _util.expect.call(void 0, _types3.TokenType.comma);
      if (_index3.eat.call(void 0, _types3.TokenType.parenR)) {
        break;
      }
    }

    parseExprListItem(false);
  }
} exports.parseCallExpressionArguments = parseCallExpressionArguments;

function shouldParseAsyncArrow() {
  return _index3.match.call